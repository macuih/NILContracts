START NILTransparencyContract

DEFINE struct Athlete {
    walletAddress
    isVerified
    array of NILContracts
    array of Transactions
}

// defines the deal itself and does not include actual payment even though details of the deal are included.
// essentially just descriptive information for auditing purposes

DEFINE struct NILContract {
    sponsorName
    contractValue (in ETH)
    description
    timestamp
    isPublic
}

// this is where actual payments are being logged.

DEFINE struct Transaction {
    fromaddress
    amount
    purpose
    timestamp
}

DECLARE mapping from walletAddress to Athlete
DECLARE array of all registered athletes

// this is a payable function for payers to pay athletes using ETH through the DAPP. 

FUNCTION payAthlete(address athleteAddress, string purpose) payable
    REQUIRE athletes[athleteAddress] is verified
    REQUIRE msg.value > 0

    SEND msg.value ETH to athleteAddress

    CREATE new Transaction:
        - fromAddress = msg.sender
        - amount = msg.value
        - purpose = purpose
        - timestamp = block.timestamp

    APPEND Transaction to athletes[athleteAddress]'s transaction log



FUNCTION registerAthlete()
    IF athlete already exists at msg.sender â†’ revert
    Create new Athlete:
        - wallet = msg.sender
        - isVerified = false
    Store in mapping

FUNCTION submitNILContract(sponsorName, value, description, isPublic)
    REQUIRE msg.sender is registered
    CREATE new NILContract struct
    APPEND to sender's NILContract array

FUNCTION logTransaction(amount, purpose, isVerified)
    REQUIRE msg.sender is registered
    CREATE new Transaction struct
    ADD to sender's log

FUNCTION viewAthleteContracts(address athleteAddress)
    IF msg.sender == athleteAddress
        RETURN all NILContracts
    ELSE
        RETURN only contracts where isPublic == true

FUNCTION verifyAthlete(address athleteAddress)
    REQUIRE msg.sender is an authorized auditor
    SET isVerified = true

END NILTransparencyContract
